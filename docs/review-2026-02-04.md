# Code Review & TODO List

**Reviewer:** Rachel (OpenClaw AI assistant)  
**Date:** 2026-02-04  
**Commit:** Initial review of v1.0 backend scaffolding

---

## Executive Summary

The backend architecture is **solid and well-designed**. The zero-knowledge model is implemented correctly, with atomic claim+delete semantics and clean separation of concerns. The codebase follows good Go conventions and has thoughtful test coverage.

**Status:** ~80% of backend core complete. No web UI yet.

---

## What's Done (‚úÖ)

### Core Features
- [x] HTTP API server with proper routing (`net/http` + `ServeMux`)
- [x] Create secret endpoint (public + API-key authenticated)
- [x] Atomic claim+delete via `DELETE ... RETURNING` (Postgres)
- [x] Burn endpoint (API-key authenticated)
- [x] Health check endpoint

### Security
- [x] Zero-knowledge design ‚Äî server stores only ciphertext envelopes
- [x] Claim token hashing (SHA-256, stored as hash only)
- [x] API key authentication with peppered hashing
- [x] Rate limiting (per-IP for public, per-key for authenticated)
- [x] Input validation (envelope size, JSON structure, claim hash format)
- [x] Request body size limits (`MaxBytesReader`)
- [x] Context timeouts on DB operations
- [x] `X-Robots-Tag: noindex` and `robots.txt` disallow
- [x] `Cache-Control: no-store` on secret pages

### Infrastructure
- [x] Config from environment variables with dotenv support
- [x] Postgres storage implementation
- [x] Database migrations (assumed, based on schema references)
- [x] CLI tool (`secretctl`) for API key management
- [x] Makefile with test/lint/govulncheck targets
- [x] golangci-lint configuration

### Testing
- [x] Table-driven tests with `t.Parallel()`
- [x] Clock injection for deterministic rate limiter tests
- [x] HTTP handler tests with `httptest`
- [x] Good coverage on core packages

---

## What's Missing (‚ùå)

### High Priority

#### 1. Expiry Reaper
**Problem:** `DeleteExpired()` exists in the storage interface but nothing calls it. Expired secrets accumulate in the database until claimed (which won't happen if TTL passes).

**Recommendation:** Add a background goroutine that runs `DeleteExpired()` periodically (e.g., every 5 minutes). Example:

```go
func (s *Server) startExpiryReaper(ctx context.Context, interval time.Duration) {
    ticker := time.NewTicker(interval)
    defer ticker.Stop()
    for {
        select {
        case <-ctx.Done():
            return
        case <-ticker.C:
            n, err := s.secrets.DeleteExpired(ctx, time.Now().UTC())
            if err != nil {
                slog.Error("expiry reaper error", "err", err)
            } else if n > 0 {
                slog.Info("expired secrets deleted", "count", n)
            }
        }
    }
}
```

#### 2. Web UI (Frontend)
**Problem:** Only placeholder HTML exists. The service is API-functional but not user-facing.

**Required components:**
- Create form: text input, TTL selector, optional passphrase
- Client-side encryption using WebCrypto (AES-GCM)
- Key derivation (HKDF for claim token + encryption key from URL fragment)
- Share page: display generated URL with fragment
- Reveal page: passphrase input, "Reveal" button, claim API call, client-side decryption
- Copy-to-clipboard functionality
- Mobile-responsive design

**Crypto flow (browser):**
```
1. Generate: k_url (random), nonce
2. If passphrase: k_pin = PBKDF2(passphrase, salt)
3. k_master = HKDF(k_url || k_pin)
4. k_enc = HKDF(k_master, "enc")
5. k_claim = HKDF(k_master, "claim")
6. ciphertext = AES-GCM(k_enc, nonce, plaintext)
7. POST envelope + H(k_claim) to server
8. URL = /s/{id}#{base64url(k_url)}
```

#### 3. CLI Client
**Problem:** No way to create/claim secrets from command line.

**Recommendation:** Add `secretctl secret create` and `secretctl secret claim` commands that:
- Perform the same crypto as the browser (for zero-knowledge parity)
- Accept plaintext from stdin or file
- Output share URL to stdout
- Support passphrase via flag or prompt

### Medium Priority

#### 4. Rate Limiter Memory Growth
**Problem:** The in-memory rate limiter uses `map[string]*bucket` which grows unboundedly. Under sustained traffic from many IPs, this will leak memory.

**Recommendation:** Add periodic pruning of stale buckets (e.g., remove entries not seen in 10 minutes), or use an LRU cache with a max size.

```go
func (l *Limiter) Prune(maxAge time.Duration) {
    l.mu.Lock()
    defer l.mu.Unlock()
    cutoff := l.now().Add(-maxAge)
    for k, b := range l.buckets {
        if b.last.Before(cutoff) {
            delete(l.buckets, k)
        }
    }
}
```

#### 5. X-Forwarded-For Handling
**Problem:** `clientIP()` intentionally ignores `X-Forwarded-For` for safety, but behind Caddy/Cloudflare, all requests appear from the proxy IP. Rate limiting won't work correctly.

**Recommendation:** Add a `TrustedProxies` config option. When set, parse XFF from trusted sources only:

```go
func clientIP(r *http.Request, trustedProxies []net.IP) string {
    if len(trustedProxies) > 0 && isTrusted(r.RemoteAddr, trustedProxies) {
        if xff := r.Header.Get("X-Forwarded-For"); xff != "" {
            // Return leftmost non-trusted IP
        }
    }
    // Fall back to RemoteAddr
}
```

#### 6. Distributed Rate Limiting
**Problem:** In-memory rate limiting doesn't work across multiple instances.

**Recommendation for v1:** Document this limitation. For v2, consider Redis-based rate limiting if horizontal scaling is needed.

### Low Priority

#### 7. Metrics / Observability
- Prometheus metrics endpoint (`/metrics`)
- Request latency histograms
- Secret create/claim/expire counters
- Rate limit hit counters

#### 8. Admin Endpoints
- `GET /api/v1/admin/stats` ‚Äî count of active secrets, expired today, etc.
- Protected by admin API key scope

#### 9. Sender Receipt / Burn Link
- Return a separate "management URL" at creation time
- Allows sender to check status (exists? expired?) and manually burn

---

## Architecture Assessment

### Strengths üí™

1. **Correct zero-knowledge model** ‚Äî Server never sees decryption keys; claim token is hashed before storage.

2. **Atomic claim semantics** ‚Äî `DELETE ... RETURNING` in a single query prevents race conditions where two clients could both receive the secret.

3. **Clean interfaces** ‚Äî `SecretsStore` and `APIKeysStore` are well-defined, making it easy to swap implementations or add SQLite support.

4. **Thoughtful rate limiting** ‚Äî Separate limiters for public create, claim, and API-key endpoints with different thresholds.

5. **Good test patterns** ‚Äî Clock injection, table-driven tests, parallel execution.

6. **Minimal dependencies** ‚Äî Mostly stdlib (`net/http`, `crypto/*`, `database/sql`, `log/slog`).

7. **Safe defaults** ‚Äî No XFF trust, strict content-type checking, request body limits.

### Potential Issues ‚ö†Ô∏è

1. **No graceful shutdown** ‚Äî If the server is killed mid-claim, a secret could be deleted without the client receiving the response. Consider adding a short grace period.

2. **No request ID / tracing** ‚Äî Makes debugging production issues harder. Consider adding a request ID middleware.

3. **Envelope validation is minimal** ‚Äî `ValidateEnvelope()` checks JSON validity and object shape, but doesn't validate crypto parameters. The client could send malformed envelopes that fail to decrypt. (Arguably fine for zero-knowledge: garbage in, garbage out.)

4. **No CORS configuration** ‚Äî If the API is meant to be called from other origins, you'll need CORS headers.

---

## Recommended Next Steps

1. **Implement expiry reaper** (30 min) ‚Äî Essential for correctness
2. **Add rate limiter pruning** (30 min) ‚Äî Prevents memory leak
3. **Design web UI architecture** (2 hr) ‚Äî Plan the WebCrypto flow
4. **Build minimal web UI** (4-8 hr) ‚Äî Create + Reveal pages with client-side crypto
5. **Add XFF handling with trusted proxies** (1 hr) ‚Äî Required for production behind Caddy

---

## Test Coverage Gaps

Run `make test-cover` to generate a coverage report. Based on code review, likely gaps:

- [ ] Concurrent claim race condition test (two goroutines claiming same secret)
- [ ] Expiry boundary conditions (claim at exactly `expires_at`)
- [ ] Large envelope handling (near `MaxEnvelopeBytes` limit)
- [ ] Malformed JSON edge cases in request parsing

---

*This document should be updated as items are completed.*
