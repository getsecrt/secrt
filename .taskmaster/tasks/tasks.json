{
  "master": {
    "tasks": [
      {
        "id": 6,
        "title": "Linux and cross-platform distribution",
        "description": "Linux binaries don't need code signing per se, but proper distribution channels need their own packaging and trust mechanisms. Musl builds and SHA-256 checksums are done via CI. Remaining: GPG signatures, Homebrew tap, crates.io, Linux package repos.",
        "status": "pending",
        "priority": "medium",
        "dependencies": [],
        "subtasks": [
          {
            "id": 1,
            "title": "Build static Linux binaries (musl)",
            "status": "done"
          },
          {
            "id": 2,
            "title": "Generate SHA-256 checksums and GPG signatures",
            "status": "pending",
            "description": "SHA-256 checksums are generated in CI. GPG signing of the checksums file is not yet implemented."
          },
          {
            "id": 3,
            "title": "Create Homebrew tap",
            "status": "pending"
          },
          {
            "id": 4,
            "title": "Publish to crates.io",
            "status": "pending"
          },
          {
            "id": 5,
            "title": "Evaluate APT/RPM/AUR packaging",
            "status": "pending"
          }
        ]
      },
      {
        "id": 8,
        "title": "Add coverage exclusion annotations to untestable code",
        "description": "Rust's #[coverage(off)] attribute is still unstable (tracking issue rust-lang/rust#134749). Once stabilized on stable Rust, annotate the ~129 lines of genuinely untestable code (main.rs I/O wiring, ring crypto internal errors, unreachable branches) so cargo llvm-cov reports accurate achievable coverage. See docs/test-coverage.md 'Theoretical Coverage Ceiling' section for the full list.",
        "status": "pending",
        "priority": "low",
        "dependencies": [],
        "subtasks": []
      },
      {
        "id": 20,
        "title": "Design and generate branded app icons",
        "description": "Replace Tauri default icons with properly branded secrt icons. Need macOS .icns (1024px source), Windows .ico + Store PNGs (Square30x30 through Square310x310, StoreLogo), Linux PNG, and optionally iOS/Android icons (dirs exist as placeholders). macOS icons should use the liquid-glass style for iOS 26 / macOS Tahoe. Windows/Chrome icons should be clean and legible at small sizes.",
        "status": "pending",
        "priority": "high",
        "dependencies": [],
        "subtasks": [
          { "id": 1, "title": "Design source icon (SVG or 1024px PNG)", "status": "pending" },
          { "id": 2, "title": "Generate macOS .icns with all required sizes", "status": "pending" },
          { "id": 3, "title": "Generate Windows .ico and Store PNGs", "status": "pending" },
          { "id": 4, "title": "Generate Linux PNG variants", "status": "pending" },
          { "id": 5, "title": "Create liquid-glass variant for macOS Tahoe / iOS 26", "status": "pending" }
        ]
      },
      {
        "id": 21,
        "title": "Code signing, notarization, and release pipeline",
        "description": "No release workflow exists for secrt-app yet. Need a GitHub Actions workflow (release-app.yml) triggered by app/vX.Y.Z tags that builds for macOS (universal binary), Windows (x64/arm64), and Linux (AppImage/deb). Must include macOS Developer ID signing + notarization and Windows Trusted Signing, mirroring the existing CLI release workflow. Without signing, users get 'unidentified developer' warnings and won't install.",
        "status": "pending",
        "priority": "high",
        "dependencies": [],
        "subtasks": [
          { "id": 1, "title": "Create release-app.yml workflow skeleton", "status": "pending" },
          { "id": 2, "title": "Configure macOS code signing and notarization", "status": "pending" },
          { "id": 3, "title": "Configure Windows Trusted Signing", "status": "pending" },
          { "id": 4, "title": "Build universal macOS binary (.dmg)", "status": "pending" },
          { "id": 5, "title": "Build Windows installer (x64/arm64)", "status": "pending" },
          { "id": 6, "title": "Build Linux packages (AppImage, deb)", "status": "pending" },
          { "id": 7, "title": "Generate SHA-256 checksums and publish GitHub Release", "status": "pending" }
        ]
      },
      {
        "id": 22,
        "title": "Fix passkey login in Tauri webview",
        "description": "WebAuthn navigator.credentials may not work correctly in Tauri's webview (WKWebView on macOS, WebView2 on Windows). Investigate whether passkey ceremonies work, and if not, implement a workaround. Options: (1) open system browser for auth and redirect back via deep link, (2) use Tauri's shell plugin to open browser for OAuth-style flow, (3) implement a session token exchange mechanism, (4) provide email/code fallback auth. This blocks authenticated features (dashboard, settings, encrypted notes, device approval).",
        "status": "pending",
        "priority": "high",
        "dependencies": [],
        "subtasks": [
          { "id": 1, "title": "Test WebAuthn in WKWebView (macOS) and WebView2 (Windows)", "status": "pending" },
          { "id": 2, "title": "Design fallback auth strategy if passkeys don't work", "status": "pending" },
          { "id": 3, "title": "Implement chosen auth solution", "status": "pending" },
          { "id": 4, "title": "Test auth flow end-to-end on macOS and Windows", "status": "pending" }
        ]
      },
      {
        "id": 23,
        "title": "Add paste-a-link support for claiming secrets",
        "description": "The Tauri app has no address bar, so users can't navigate to secrt.ca/s/... links directly. Need a way for users to paste a share link and have the app navigate to the claim page. Options: (1) text input field on the home page with a 'Claim' button, (2) global paste handler (Cmd+V when no input focused) that detects secrt URLs, (3) both. Should parse the pasted URL, extract the secret ID and fragment key, and navigate to the claim route internally.",
        "status": "pending",
        "priority": "high",
        "dependencies": [],
        "subtasks": [
          { "id": 1, "title": "Add URL input / paste field to SendPage or Nav", "status": "pending" },
          { "id": 2, "title": "Parse pasted URLs and extract ID + fragment key", "status": "pending" },
          { "id": 3, "title": "Navigate to internal claim route with parsed data", "status": "pending" },
          { "id": 4, "title": "Add global Cmd+V paste handler for secrt URLs", "status": "pending" }
        ]
      },
      {
        "id": 24,
        "title": "Auto-clear clipboard after copying secrets",
        "description": "Secrets copied to clipboard should be automatically cleared after a configurable timeout (default 30-60 seconds). Use Tauri's clipboard-manager plugin for native clipboard access. Add a visible countdown or toast so users know when the clipboard will be cleared. Should apply to: share link copies, claimed secret text copies, generated password copies.",
        "status": "pending",
        "priority": "high",
        "dependencies": [],
        "subtasks": [
          { "id": 1, "title": "Add tauri-plugin-clipboard-manager dependency", "status": "pending" },
          { "id": 2, "title": "Update capabilities/default.json with clipboard permissions", "status": "pending" },
          { "id": 3, "title": "Implement timed clipboard clear in clipboard.ts for Tauri", "status": "pending" },
          { "id": 4, "title": "Add countdown toast/indicator for clipboard clear", "status": "pending" }
        ]
      },
      {
        "id": 25,
        "title": "Verify native crypto end-to-end with spec test vectors",
        "description": "The Rust crypto bridge (seal_secret, open_secret, derive_claim_token) is wired up and the envelope dispatcher routes to native in Tauri, but needs end-to-end verification. Run the spec test vectors from spec/v1/envelope.vectors.json through the Tauri IPC path to confirm the native crypto produces identical results to the WebCrypto path. Also verify compression/decompression round-trips correctly.",
        "status": "done",
        "priority": "high",
        "dependencies": [],
        "subtasks": [
          { "id": 1, "title": "Write test harness that invokes Tauri commands with vector inputs", "status": "done" },
          { "id": 2, "title": "Verify all 5 envelope test vectors pass through native path", "status": "done" },
          { "id": 3, "title": "Test compression round-trip (text and file payloads)", "status": "done" },
          { "id": 4, "title": "Test passphrase-protected secrets through native path", "status": "done" }
        ]
      },
      {
        "id": 26,
        "title": "Configure auto-updater",
        "description": "Add Tauri's updater plugin so the app can check for and install updates. Critical for a security tool — need to push fixes fast. Requires a signed update manifest hosted somewhere (GitHub Releases or a dedicated endpoint). The updater should check on app launch and optionally on a timer, with a non-intrusive notification when updates are available.",
        "status": "pending",
        "priority": "medium",
        "dependencies": [21],
        "subtasks": [
          { "id": 1, "title": "Add tauri-plugin-updater dependency", "status": "pending" },
          { "id": 2, "title": "Configure update endpoint (GitHub Releases or custom)", "status": "pending" },
          { "id": 3, "title": "Implement update check on app launch", "status": "pending" },
          { "id": 4, "title": "Add update notification UI", "status": "pending" },
          { "id": 5, "title": "Sign update manifests in release pipeline", "status": "pending" }
        ]
      },
      {
        "id": 27,
        "title": "Register deep links for secrt.ca URLs",
        "description": "Register the app to handle secrt.ca URLs and/or a secrt:// custom protocol so clicking a share link opens the desktop app instead of the browser. Tauri 2 has a deep-link plugin. macOS Universal Links require an apple-app-site-association file on the server. Windows uses URI protocol handlers. Linux uses .desktop file handlers. Consider also registering for secrt:// as a fallback protocol.",
        "status": "pending",
        "priority": "medium",
        "dependencies": [23],
        "subtasks": [
          { "id": 1, "title": "Add tauri-plugin-deep-link dependency and permissions", "status": "pending" },
          { "id": 2, "title": "Register secrt:// custom protocol on all platforms", "status": "pending" },
          { "id": 3, "title": "Investigate macOS Universal Links (apple-app-site-association)", "status": "pending" },
          { "id": 4, "title": "Handle incoming deep links and route to claim page", "status": "pending" },
          { "id": 5, "title": "Test deep links on macOS, Windows, and Linux", "status": "pending" }
        ]
      },
      {
        "id": 28,
        "title": "Add keyboard shortcuts",
        "description": "Desktop app users expect standard keyboard shortcuts. Implement: Cmd/Ctrl+N (new secret), Cmd/Ctrl+V (paste link when no input focused), Cmd/Ctrl+, (settings), Cmd/Ctrl+W (close window). Use Tauri's global shortcut plugin or frontend key event handlers.",
        "status": "pending",
        "priority": "medium",
        "dependencies": [],
        "subtasks": [
          { "id": 1, "title": "Define shortcut map for all platforms", "status": "pending" },
          { "id": 2, "title": "Implement shortcut handler (Tauri plugin or JS keydown)", "status": "pending" },
          { "id": 3, "title": "Add Cmd+V global paste-link handler", "status": "pending" },
          { "id": 4, "title": "Test shortcuts on macOS and Windows", "status": "pending" }
        ]
      },
      {
        "id": 29,
        "title": "Add offline state detection and messaging",
        "description": "The app requires network to create or claim secrets. Add graceful offline detection using navigator.onLine and online/offline events. Show a clear banner or toast when offline. Disable create/claim actions with explanation. Re-enable automatically when connectivity returns.",
        "status": "pending",
        "priority": "medium",
        "dependencies": [],
        "subtasks": [
          { "id": 1, "title": "Add online/offline event listeners", "status": "pending" },
          { "id": 2, "title": "Show offline banner in Layout", "status": "pending" },
          { "id": 3, "title": "Disable form submissions when offline", "status": "pending" }
        ]
      },
      {
        "id": 30,
        "title": "Add About screen with version info",
        "description": "Users need to see what version they're running, especially for a security tool. Add an About screen or section (accessible from menu or settings) showing app version, build info, and links to the project. Tauri provides app version via the API.",
        "status": "pending",
        "priority": "medium",
        "dependencies": [],
        "subtasks": [
          { "id": 1, "title": "Create About page or modal with version, build, and links", "status": "pending" },
          { "id": 2, "title": "Read version from Tauri app API", "status": "pending" },
          { "id": 3, "title": "Add navigation to About from settings or menu", "status": "pending" }
        ]
      },
      {
        "id": 31,
        "title": "Harden CSP and audit permissions",
        "description": "Current CSP allows 'unsafe-inline' for scripts and styles. For production, tighten the CSP (nonces or hashes for inline scripts if possible). Audit capabilities/default.json to ensure only necessary permissions are granted — add clipboard, deep-link, updater permissions as needed but nothing extra. Review connect-src to ensure only secrt.ca is allowed.",
        "status": "pending",
        "priority": "medium",
        "dependencies": [24, 26, 27],
        "subtasks": [
          { "id": 1, "title": "Audit and tighten CSP in tauri.conf.json", "status": "pending" },
          { "id": 2, "title": "Audit capabilities/default.json for minimal permissions", "status": "pending" },
          { "id": 3, "title": "Test that app functions correctly with tightened policies", "status": "pending" }
        ]
      },
      {
        "id": 32,
        "title": "Add file drag-and-drop support",
        "description": "The web app supports file upload via file picker, but native drag-and-drop onto the app window would improve UX. Tauri supports drag-drop events. When a file is dropped, populate the send form with the file contents. Optionally support dropping onto the dock icon (macOS) to launch with a file ready to send.",
        "status": "pending",
        "priority": "low",
        "dependencies": [],
        "subtasks": [
          { "id": 1, "title": "Enable drag-drop in Tauri window config", "status": "pending" },
          { "id": 2, "title": "Handle drop events and populate send form", "status": "pending" },
          { "id": 3, "title": "Test with various file types and sizes", "status": "pending" }
        ]
      },
      {
        "id": 33,
        "title": "Add system tray with quick actions",
        "description": "Optional system tray icon for quick access. Could show: 'Create Secret' (opens main window), 'Paste Link' (claim from clipboard), 'Quit'. Useful for users who want the app always accessible without keeping a window open.",
        "status": "pending",
        "priority": "low",
        "dependencies": [],
        "subtasks": [
          { "id": 1, "title": "Add tauri-plugin-tray dependency and icon", "status": "pending" },
          { "id": 2, "title": "Configure tray menu items", "status": "pending" },
          { "id": 3, "title": "Handle tray actions (open window, paste-claim, quit)", "status": "pending" }
        ]
      },
      {
        "id": 34,
        "title": "Add keychain storage for session and default passphrase",
        "description": "Store session tokens and optional default passphrases in the OS keychain (macOS Keychain, Windows Credential Manager, Linux Secret Service) instead of localStorage. The CLI already has keychain support. Use Tauri's stronghold plugin or a keychain plugin. Also support saving default encryption/decryption passphrases like the CLI config does.",
        "status": "pending",
        "priority": "low",
        "dependencies": [22],
        "subtasks": [
          { "id": 1, "title": "Evaluate Tauri keychain/stronghold plugins", "status": "pending" },
          { "id": 2, "title": "Migrate session token storage from localStorage to keychain", "status": "pending" },
          { "id": 3, "title": "Add default passphrase save/load from keychain", "status": "pending" },
          { "id": 4, "title": "Add settings UI for managing stored passphrases", "status": "pending" }
        ]
      },
      {
        "id": 35,
        "title": "Customize window chrome for native feel",
        "description": "Polish the window appearance: custom titlebar or transparent titlebar with traffic light positioning on macOS, proper window title, window menu bar. Consider whether a frameless window with custom drag region looks better than the default chrome.",
        "status": "pending",
        "priority": "low",
        "dependencies": [],
        "subtasks": [
          { "id": 1, "title": "Experiment with titlebar styles on macOS and Windows", "status": "pending" },
          { "id": 2, "title": "Adjust traffic light position if using transparent titlebar", "status": "pending" },
          { "id": 3, "title": "Add custom drag region if frameless", "status": "pending" }
        ]
      },
      {
        "id": 36,
        "title": "Re-evaluate macOS Keychain after Tahoe fix",
        "description": "macOS Tahoe 26 has a regression where SecItemAdd succeeds but SecItemCopyMatching returns errSecItemNotFound (-25300) for the same item in the same process. This breaks the keyring crate (v3.6.3) completely. We added a file-based fallback (~Library/Application Support/ca.secrt.app/credentials.json) that auto-activates when a probe detects the broken keychain. Periodically re-test: (1) run `cargo test -p secrt-app keyring_probe` to check if Apple has fixed it, (2) test with newer keyring crate versions (v4 was RC as of Feb 2026), (3) once keychain works again, the fallback auto-deactivates. Also check if Entitlements.plist (added for production builds) affects behavior. References: https://dev.to/euda1mon1a/macos-tahoe-broke-keychain-cli-reads-novel-findings-from-an-ai-agent-deployment-2p3o",
        "status": "pending",
        "priority": "high",
        "dependencies": [],
        "subtasks": [
          { "id": 1, "title": "Re-test keychain on next macOS update", "status": "pending" },
          { "id": 2, "title": "Test keyring crate v4 stable when released", "status": "pending" },
          { "id": 3, "title": "Remove file fallback once keychain works reliably", "status": "pending" }
        ]
      },
      {
        "id": 15,
        "title": "Investigate app-layer IP privacy and deployment posture signaling",
        "description": "Explore whether secrt-server should truncate/hash IP addresses at the application layer (before rate limiting, owner_key derivation, or any logging) so the app itself never processes full IPs — regardless of reverse proxy configuration.\n\nRelated but distinct from task #10 (hash owner_key): this is broader and includes investigating what observable privacy properties the server could honestly assert and signal to clients.\n\nAreas to investigate:\n\n1. **App-layer IP truncation** — Truncate IPs (zero last octet for IPv4, last 80 bits for IPv6) immediately on receipt, before any use. This is a real, code-level guarantee the app controls. Evaluate impact on rate limiting accuracy and quota enforcement. Compare with the HMAC approach in task #10.\n\n2. **Client-observable signals** — What can the CLI or web client actually verify from the outside? E.g., TLS version, HSTS, absence of Server header, response headers. Identify which deployment properties are externally testable vs. trust-based.\n\n3. **Privacy posture endpoint/header** — Evaluate whether a lightweight mechanism (e.g., a response header or /.well-known/secrt.json) declaring the server's privacy posture is worthwhile. Prior art: security.txt (RFC 9116, successful), P3P (dead), Tk header (deprecated), privacy.txt IETF draft (stalled), GPC .well-known/gpc.json (active but different scope). Key tension: these are self-attested and unverifiable. Only worth doing if the CLI would act on it (e.g., warn if a server doesn't claim zero-knowledge).\n\n4. **Scope boundary** — Clearly document what the app layer can guarantee vs. what requires operator trust (reverse proxy log config, TLS termination, etc.). This is important for the project's security narrative.\n\nGoal: produce a recommendation on what (if anything) to implement, with clear rationale. May result in concrete subtasks or a 'not worth it' conclusion.",
        "status": "pending",
        "priority": "low",
        "dependencies": [],
        "subtasks": [
          {
            "id": 1,
            "title": "Evaluate app-layer IP truncation: impact on rate limiting and quota accuracy",
            "status": "pending"
          },
          {
            "id": 2,
            "title": "Inventory client-observable deployment properties (TLS, headers, etc.)",
            "status": "pending"
          },
          {
            "id": 3,
            "title": "Assess privacy posture signaling: header vs .well-known vs skip",
            "status": "pending"
          },
          {
            "id": 4,
            "title": "Document app-layer vs operator-layer privacy guarantees boundary",
            "status": "pending"
          },
          {
            "id": 5,
            "title": "Write recommendation with rationale",
            "status": "pending"
          }
        ]
      }
    ]
  }
}
