{
  "master": {
    "tasks": [
      {
        "id": 6,
        "title": "Linux and cross-platform distribution",
        "description": "Linux binaries don't need code signing per se, but proper distribution channels need their own packaging and trust mechanisms. Musl builds and SHA-256 checksums are done via CI. Remaining: GPG signatures, Homebrew tap, crates.io, Linux package repos.",
        "status": "pending",
        "priority": "medium",
        "dependencies": [],
        "subtasks": [
          {
            "id": 1,
            "title": "Build static Linux binaries (musl)",
            "status": "done"
          },
          {
            "id": 2,
            "title": "Generate SHA-256 checksums and GPG signatures",
            "status": "pending",
            "description": "SHA-256 checksums are generated in CI. GPG signing of the checksums file is not yet implemented."
          },
          {
            "id": 3,
            "title": "Create Homebrew tap",
            "status": "pending"
          },
          {
            "id": 4,
            "title": "Publish to crates.io",
            "status": "pending"
          },
          {
            "id": 5,
            "title": "Evaluate APT/RPM/AUR packaging",
            "status": "pending"
          }
        ]
      },
      {
        "id": 8,
        "title": "Add coverage exclusion annotations to untestable code",
        "description": "Rust's #[coverage(off)] attribute is still unstable (tracking issue rust-lang/rust#134749). Once stabilized on stable Rust, annotate the ~129 lines of genuinely untestable code (main.rs I/O wiring, ring crypto internal errors, unreachable branches) so cargo llvm-cov reports accurate achievable coverage. See docs/test-coverage.md 'Theoretical Coverage Ceiling' section for the full list.",
        "status": "pending",
        "priority": "low",
        "dependencies": [],
        "subtasks": []
      },
      {
        "id": 20,
        "title": "Design and generate branded app icons",
        "description": "Replace Tauri default icons with properly branded secrt icons. Need macOS .icns (1024px source), Windows .ico + Store PNGs (Square30x30 through Square310x310, StoreLogo), Linux PNG, and optionally iOS/Android icons (dirs exist as placeholders). macOS icons should use the liquid-glass style for iOS 26 / macOS Tahoe. Windows/Chrome icons should be clean and legible at small sizes.",
        "status": "pending",
        "priority": "high",
        "dependencies": [],
        "subtasks": [
          {
            "id": 1,
            "title": "Design source icon (SVG or 1024px PNG)",
            "status": "pending"
          },
          {
            "id": 2,
            "title": "Generate macOS .icns with all required sizes",
            "status": "pending"
          },
          {
            "id": 3,
            "title": "Generate Windows .ico and Store PNGs",
            "status": "pending"
          },
          {
            "id": 4,
            "title": "Generate Linux PNG variants",
            "status": "pending"
          },
          {
            "id": 5,
            "title": "Create liquid-glass variant for macOS Tahoe / iOS 26",
            "status": "done"
          }
        ]
      },
      {
        "id": 21,
        "title": "Code signing, notarization, and release pipeline",
        "description": "No release workflow exists for secrt-app yet. Need a GitHub Actions workflow (release-app.yml) triggered by app/vX.Y.Z tags that builds for macOS (universal binary), Windows (x64/arm64), and Linux (AppImage/deb). Must include macOS Developer ID signing + notarization and Windows Trusted Signing, mirroring the existing CLI release workflow. Without signing, users get 'unidentified developer' warnings and won't install.",
        "status": "pending",
        "priority": "high",
        "dependencies": [],
        "subtasks": [
          {
            "id": 1,
            "title": "Create release-app.yml workflow skeleton",
            "status": "pending"
          },
          {
            "id": 2,
            "title": "Configure macOS code signing and notarization",
            "status": "pending"
          },
          {
            "id": 3,
            "title": "Configure Windows Trusted Signing",
            "status": "pending"
          },
          {
            "id": 4,
            "title": "Build universal macOS binary (.dmg)",
            "status": "pending"
          },
          {
            "id": 5,
            "title": "Build Windows installer (x64/arm64)",
            "status": "pending"
          },
          {
            "id": 6,
            "title": "Build Linux packages (AppImage, deb)",
            "status": "pending"
          },
          {
            "id": 7,
            "title": "Generate SHA-256 checksums and publish GitHub Release",
            "status": "pending"
          }
        ]
      },
      {
        "id": 23,
        "title": "Add paste-a-link support for claiming secrets",
        "description": "The Tauri app has no address bar, so users can't navigate to secrt.ca/s/... links directly. Need a way for users to paste a share link and have the app navigate to the claim page. Options: (1) text input field on the home page with a 'Claim' button, (2) global paste handler (Cmd+V when no input focused) that detects secrt URLs, (3) both. Should parse the pasted URL, extract the secret ID and fragment key, and navigate to the claim route internally.",
        "status": "done",
        "priority": "high",
        "dependencies": [],
        "subtasks": [
          {
            "id": 1,
            "title": "Add URL input / paste field to SendPage or Nav",
            "status": "done"
          },
          {
            "id": 2,
            "title": "Parse pasted URLs and extract ID + fragment key",
            "status": "done"
          },
          {
            "id": 3,
            "title": "Navigate to internal claim route with parsed data",
            "status": "done"
          },
          {
            "id": 4,
            "title": "Add global Cmd+V paste handler for secrt URLs",
            "status": "done",
            "description": "Intentionally skipped — manual paste into input is more secure than auto-detecting clipboard content"
          }
        ]
      },
      {
        "id": 24,
        "title": "Auto-clear clipboard after copying secrets",
        "description": "Secrets copied to clipboard should be automatically cleared after a configurable timeout (default 30-60 seconds). Use Tauri's clipboard-manager plugin for native clipboard access. Add a visible countdown or toast so users know when the clipboard will be cleared. Should apply to: share link copies, claimed secret text copies, generated password copies. DEFERRED: UX frustration concerns outweigh marginal security benefit — if an attacker has clipboard access they likely have screen access too. Revisit if users request it.",
        "status": "deferred",
        "priority": "high",
        "dependencies": [],
        "subtasks": [
          {
            "id": 1,
            "title": "Add tauri-plugin-clipboard-manager dependency",
            "status": "pending"
          },
          {
            "id": 2,
            "title": "Update capabilities/default.json with clipboard permissions",
            "status": "pending"
          },
          {
            "id": 3,
            "title": "Implement timed clipboard clear in clipboard.ts for Tauri",
            "status": "pending"
          },
          {
            "id": 4,
            "title": "Add countdown toast/indicator for clipboard clear",
            "status": "pending"
          }
        ]
      },
      {
        "id": 26,
        "title": "Configure auto-updater",
        "description": "Add Tauri's updater plugin so the app can check for and install updates. Critical for a security tool — need to push fixes fast. Requires a signed update manifest hosted somewhere (GitHub Releases or a dedicated endpoint). The updater should check on app launch and optionally on a timer, with a non-intrusive notification when updates are available.",
        "status": "pending",
        "priority": "medium",
        "dependencies": [
          21
        ],
        "subtasks": [
          {
            "id": 1,
            "title": "Add tauri-plugin-updater dependency",
            "status": "pending"
          },
          {
            "id": 2,
            "title": "Configure update endpoint (GitHub Releases or custom)",
            "status": "pending"
          },
          {
            "id": 3,
            "title": "Implement update check on app launch",
            "status": "pending"
          },
          {
            "id": 4,
            "title": "Add update notification UI",
            "status": "pending"
          },
          {
            "id": 5,
            "title": "Sign update manifests in release pipeline",
            "status": "pending"
          }
        ]
      },
      {
        "id": 27,
        "title": "Register deep links for secrt.ca URLs",
        "description": "Register the app to handle secrt.ca URLs and/or a secrt:// custom protocol so clicking a share link opens the desktop app instead of the browser. Tauri 2 has a deep-link plugin. macOS Universal Links require an apple-app-site-association file on the server. Windows uses URI protocol handlers. Linux uses .desktop file handlers. Consider also registering for secrt:// as a fallback protocol.",
        "status": "pending",
        "priority": "medium",
        "dependencies": [
          23
        ],
        "subtasks": [
          {
            "id": 1,
            "title": "Add tauri-plugin-deep-link dependency and permissions",
            "status": "pending"
          },
          {
            "id": 2,
            "title": "Register secrt:// custom protocol on all platforms",
            "status": "pending"
          },
          {
            "id": 3,
            "title": "Investigate macOS Universal Links (apple-app-site-association)",
            "status": "pending"
          },
          {
            "id": 4,
            "title": "Handle incoming deep links and route to claim page",
            "status": "pending"
          },
          {
            "id": 5,
            "title": "Test deep links on macOS, Windows, and Linux",
            "status": "pending"
          }
        ]
      },
      {
        "id": 28,
        "title": "Add keyboard shortcuts",
        "description": "Desktop app users expect standard keyboard shortcuts. Implement: Cmd/Ctrl+N (new secret), Cmd/Ctrl+V (paste link when no input focused), Cmd/Ctrl+, (settings), Cmd/Ctrl+W (close window). Use Tauri's global shortcut plugin or frontend key event handlers.",
        "status": "pending",
        "priority": "medium",
        "dependencies": [],
        "subtasks": [
          {
            "id": 1,
            "title": "Define shortcut map for all platforms",
            "status": "pending"
          },
          {
            "id": 2,
            "title": "Implement shortcut handler (Tauri plugin or JS keydown)",
            "status": "pending"
          },
          {
            "id": 3,
            "title": "Add Cmd+V global paste-link handler",
            "status": "pending"
          },
          {
            "id": 4,
            "title": "Test shortcuts on macOS and Windows",
            "status": "pending"
          }
        ]
      },
      {
        "id": 29,
        "title": "Add offline state detection and messaging",
        "description": "The app requires network to create or claim secrets. Add graceful offline detection using navigator.onLine and online/offline events. Show a clear banner or toast when offline. Disable create/claim actions with explanation. Re-enable automatically when connectivity returns.",
        "status": "done",
        "priority": "medium",
        "dependencies": [],
        "subtasks": [
          {
            "id": 1,
            "title": "Add online/offline event listeners",
            "status": "done"
          },
          {
            "id": 2,
            "title": "Show offline banner in Layout",
            "status": "done"
          },
          {
            "id": 3,
            "title": "Disable form submissions when offline",
            "status": "done"
          }
        ]
      },
      {
        "id": 30,
        "title": "Add About screen with version info",
        "description": "Users need to see what version they're running, especially for a security tool. Add an About screen or section (accessible from menu or settings) showing app version, build info, and links to the project. Tauri provides app version via the API.",
        "status": "pending",
        "priority": "medium",
        "dependencies": [],
        "subtasks": [
          {
            "id": 1,
            "title": "Create About page or modal with version, build, and links",
            "status": "pending"
          },
          {
            "id": 2,
            "title": "Read version from Tauri app API",
            "status": "pending"
          },
          {
            "id": 3,
            "title": "Add navigation to About from settings or menu",
            "status": "pending"
          }
        ]
      },
      {
        "id": 31,
        "title": "Harden CSP and audit permissions",
        "description": "Current CSP allows 'unsafe-inline' for scripts and styles. For production, tighten the CSP (nonces or hashes for inline scripts if possible). Audit capabilities/default.json to ensure only necessary permissions are granted — add clipboard, deep-link, updater permissions as needed but nothing extra. Review connect-src to ensure only secrt.ca is allowed.",
        "status": "pending",
        "priority": "medium",
        "dependencies": [
          24,
          26,
          27
        ],
        "subtasks": [
          {
            "id": 1,
            "title": "Audit and tighten CSP in tauri.conf.json",
            "status": "pending"
          },
          {
            "id": 2,
            "title": "Audit capabilities/default.json for minimal permissions",
            "status": "pending"
          },
          {
            "id": 3,
            "title": "Test that app functions correctly with tightened policies",
            "status": "pending"
          }
        ]
      },
      {
        "id": 32,
        "title": "Add file drag-and-drop support",
        "description": "The web app supports file upload via file picker, but native drag-and-drop onto the app window would improve UX. Tauri supports drag-drop events. When a file is dropped, populate the send form with the file contents. Optionally support dropping onto the dock icon (macOS) to launch with a file ready to send.",
        "status": "pending",
        "priority": "low",
        "dependencies": [],
        "subtasks": [
          {
            "id": 1,
            "title": "Enable drag-drop in Tauri window config",
            "status": "pending"
          },
          {
            "id": 2,
            "title": "Handle drop events and populate send form",
            "status": "pending"
          },
          {
            "id": 3,
            "title": "Test with various file types and sizes",
            "status": "pending"
          }
        ]
      },
      {
        "id": 33,
        "title": "Add system tray with quick actions",
        "description": "Optional system tray icon for quick access. Could show: 'Create Secret' (opens main window), 'Paste Link' (claim from clipboard), 'Quit'. Useful for users who want the app always accessible without keeping a window open.",
        "status": "pending",
        "priority": "low",
        "dependencies": [],
        "subtasks": [
          {
            "id": 1,
            "title": "Add tauri-plugin-tray dependency and icon",
            "status": "pending"
          },
          {
            "id": 2,
            "title": "Configure tray menu items",
            "status": "pending"
          },
          {
            "id": 3,
            "title": "Handle tray actions (open window, paste-claim, quit)",
            "status": "pending"
          }
        ]
      },
      {
        "id": 34,
        "title": "Add keychain storage for session and default passphrase",
        "description": "Store session tokens and optional default passphrases in the OS keychain (macOS Keychain, Windows Credential Manager, Linux Secret Service) instead of localStorage. The CLI already has keychain support. Use Tauri's stronghold plugin or a keychain plugin. Also support saving default encryption/decryption passphrases like the CLI config does. NOTE: The app already has keyring_set/keyring_get/keyring_delete Tauri commands with a file-based fallback for broken macOS Tahoe keychain. This task is about expanding usage to cover session tokens and passphrase storage, plus building the preferences UI (see task #37).",
        "status": "pending",
        "priority": "high",
        "dependencies": [],
        "subtasks": [
          {
            "id": 1,
            "title": "Evaluate Tauri keychain/stronghold plugins",
            "status": "done",
            "description": "Already using keyring crate with file-based fallback. Keyring commands (keyring_set/get/delete) already exist in the Tauri backend."
          },
          {
            "id": 2,
            "title": "Migrate session token storage from localStorage to keychain",
            "status": "pending"
          },
          {
            "id": 3,
            "title": "Store default encryption passphrase in keychain",
            "status": "pending",
            "description": "Save a default passphrase (like CLI config 'passphrase') that is auto-applied when sending secrets. Stored via keyring_set with a dedicated key prefix."
          },
          {
            "id": 4,
            "title": "Store decryption passphrases list in keychain",
            "status": "pending",
            "description": "Save a list of passphrases to try automatically when claiming secrets (like CLI config 'decryption_passphrases'). Stored as JSON array via keyring."
          }
        ]
      },
      {
        "id": 35,
        "title": "Customize window chrome for native feel",
        "description": "The app currently looks like a webpage in a light wrapper. Make it feel like a real native app, starting with macOS. Use Tauri's window configuration for transparent/hidden titlebar, position traffic light buttons within the content area, add a custom drag region at the top of the layout. On Windows, consider custom titlebar or standard chrome (less jarring). May need vibrancy/blur effects on macOS for a polished look. The Nav component and Layout will need adjustments to account for the titlebar area.",
        "status": "pending",
        "priority": "high",
        "dependencies": [],
        "subtasks": [
          {
            "id": 1,
            "title": "Configure transparent/hidden titlebar on macOS in tauri.conf.json",
            "status": "pending",
            "description": "Set titleBarStyle to 'overlay' or 'transparent' and hiddenTitle to true. Test with Tauri 2's macOS window options."
          },
          {
            "id": 2,
            "title": "Position traffic light buttons and add drag region",
            "status": "pending",
            "description": "Use Tauri's trafficLightPosition config. Add data-tauri-drag-region to a top bar element in Layout. Ensure the Nav component has enough top padding to not overlap traffic lights."
          },
          {
            "id": 3,
            "title": "Update Layout/Nav CSS for titlebar-integrated design",
            "status": "pending",
            "description": "Add platform-aware top padding. On macOS with hidden titlebar, the content needs ~28-32px top inset. Use Tauri's platform detection or CSS env(titlebar-area-*)."
          },
          {
            "id": 4,
            "title": "Test on Windows and Linux",
            "status": "pending",
            "description": "Ensure standard window chrome works well on Windows/Linux. May keep default decorations there or add a custom titlebar later."
          }
        ]
      },
      {
        "id": 36,
        "title": "Re-evaluate macOS Keychain after Tahoe fix",
        "description": "macOS Tahoe 26 has a regression where SecItemAdd succeeds but SecItemCopyMatching returns errSecItemNotFound (-25300) for the same item in the same process. This breaks the keyring crate (v3.6.3) completely. We added a file-based fallback (~Library/Application Support/ca.secrt.app/credentials.json) that auto-activates when a probe detects the broken keychain. Periodically re-test: (1) run `cargo test -p secrt-app keyring_probe` to check if Apple has fixed it, (2) test with newer keyring crate versions (v4 was RC as of Feb 2026), (3) once keychain works again, the fallback auto-deactivates. Also check if Entitlements.plist (added for production builds) affects behavior. References: https://dev.to/euda1mon1a/macos-tahoe-broke-keychain-cli-reads-novel-findings-from-an-ai-agent-deployment-2p3o",
        "status": "pending",
        "priority": "high",
        "dependencies": [],
        "subtasks": [
          {
            "id": 1,
            "title": "Re-test keychain on next macOS update",
            "status": "pending"
          },
          {
            "id": 2,
            "title": "Test keyring crate v4 stable when released",
            "status": "pending"
          },
          {
            "id": 3,
            "title": "Remove file fallback once keychain works reliably",
            "status": "pending"
          }
        ]
      },
      {
        "id": 15,
        "title": "Investigate app-layer IP privacy and deployment posture signaling",
        "description": "Explore whether secrt-server should truncate/hash IP addresses at the application layer (before rate limiting, owner_key derivation, or any logging) so the app itself never processes full IPs — regardless of reverse proxy configuration.\n\nRelated but distinct from task #10 (hash owner_key): this is broader and includes investigating what observable privacy properties the server could honestly assert and signal to clients.\n\nAreas to investigate:\n\n1. **App-layer IP truncation** — Truncate IPs (zero last octet for IPv4, last 80 bits for IPv6) immediately on receipt, before any use. This is a real, code-level guarantee the app controls. Evaluate impact on rate limiting accuracy and quota enforcement. Compare with the HMAC approach in task #10.\n\n2. **Client-observable signals** — What can the CLI or web client actually verify from the outside? E.g., TLS version, HSTS, absence of Server header, response headers. Identify which deployment properties are externally testable vs. trust-based.\n\n3. **Privacy posture endpoint/header** — Evaluate whether a lightweight mechanism (e.g., a response header or /.well-known/secrt.json) declaring the server's privacy posture is worthwhile. Prior art: security.txt (RFC 9116, successful), P3P (dead), Tk header (deprecated), privacy.txt IETF draft (stalled), GPC .well-known/gpc.json (active but different scope). Key tension: these are self-attested and unverifiable. Only worth doing if the CLI would act on it (e.g., warn if a server doesn't claim zero-knowledge).\n\n4. **Scope boundary** — Clearly document what the app layer can guarantee vs. what requires operator trust (reverse proxy log config, TLS termination, etc.). This is important for the project's security narrative.\n\nGoal: produce a recommendation on what (if anything) to implement, with clear rationale. May result in concrete subtasks or a 'not worth it' conclusion.",
        "status": "pending",
        "priority": "low",
        "dependencies": [],
        "subtasks": [
          {
            "id": 1,
            "title": "Evaluate app-layer IP truncation: impact on rate limiting and quota accuracy",
            "status": "pending"
          },
          {
            "id": 2,
            "title": "Inventory client-observable deployment properties (TLS, headers, etc.)",
            "status": "pending"
          },
          {
            "id": 3,
            "title": "Assess privacy posture signaling: header vs .well-known vs skip",
            "status": "pending"
          },
          {
            "id": 4,
            "title": "Document app-layer vs operator-layer privacy guarantees boundary",
            "status": "pending"
          },
          {
            "id": 5,
            "title": "Write recommendation with rationale",
            "status": "pending"
          }
        ]
      },
      {
        "id": 37,
        "title": "Add app preferences page and storage layer",
        "description": "Create an app-level Preferences page (distinct from /settings which is account-level). This is the UI and storage backbone for local app configuration, mirroring the CLI's config.toml but for the desktop/web app. Store preferences in localStorage (web) or Tauri's store plugin (desktop). Preferences include: default TTL, auto-copy share link toggle, theme preference. The preferences page should be accessible from the Nav (gear icon or menu item). This task does NOT include passphrase management (that's task #38) — it's the foundation that #38 builds on.",
        "status": "pending",
        "priority": "high",
        "dependencies": [],
        "subtasks": [
          {
            "id": 1,
            "title": "Create preferences store (localStorage + Tauri store plugin)",
            "status": "pending",
            "description": "Build a preferences module (e.g., web/src/lib/preferences.ts) with get/set/subscribe. Use localStorage for web, Tauri store plugin for desktop. Keys: default_ttl, auto_copy, theme. Provide React-friendly hook (usePreference)."
          },
          {
            "id": 2,
            "title": "Create Preferences page UI",
            "status": "pending",
            "description": "New route /preferences with sections for: General (default TTL dropdown, auto-copy toggle), Appearance (theme selector). Clean, native-feeling form layout. Distinct from /settings (account management)."
          },
          {
            "id": 3,
            "title": "Wire default TTL into SendPage",
            "status": "pending",
            "description": "SendPage's TTL selector should initialize from the saved default_ttl preference instead of hardcoded default."
          },
          {
            "id": 4,
            "title": "Add Preferences link to Nav",
            "status": "pending",
            "description": "Add gear icon or 'Preferences' menu item to Nav component. On macOS desktop, also respond to Cmd+, shortcut."
          }
        ]
      },
      {
        "id": 38,
        "title": "Add saved passphrases and auto-decryption",
        "description": "Port the CLI's passphrase management to the app. Two features: (1) Default encryption passphrase — automatically applied when creating secrets (user can override or clear per-secret). (2) Decryption passphrases list — when claiming a secret, automatically try: no passphrase → default passphrase → each saved decryption passphrase → prompt user. This mirrors the CLI's multi-phase auto-decryption from config.toml. Passphrases are stored in the OS keychain via existing keyring_set/get commands (with file fallback on broken macOS). The Preferences page (task #37) provides the management UI.",
        "status": "pending",
        "priority": "high",
        "dependencies": [37, 34],
        "subtasks": [
          {
            "id": 1,
            "title": "Add passphrase management UI to Preferences page",
            "status": "pending",
            "description": "Section in Preferences for: (a) Default encryption passphrase — masked input with show/hide toggle, save/clear buttons. (b) Decryption passphrases — ordered list with add/remove/reorder. All stored via keyring commands."
          },
          {
            "id": 2,
            "title": "Auto-apply default passphrase on send",
            "status": "pending",
            "description": "When SendPage loads, check for a saved default passphrase. If present, pre-populate the passphrase field (or apply silently). Show indicator that default passphrase is active. Allow user to clear/override per-secret. Add a 'no passphrase' toggle to explicitly skip."
          },
          {
            "id": 3,
            "title": "Implement multi-phase auto-decryption on claim",
            "status": "pending",
            "description": "When claiming a secret that requires a passphrase, try in order: (1) no passphrase, (2) default passphrase, (3) each decryption passphrase from the saved list. If all fail, show the passphrase prompt as today. Show a brief status like 'Trying saved passphrases...' during auto-attempts. Don't leak which passphrase worked."
          },
          {
            "id": 4,
            "title": "Add passphrase import/export for CLI config parity",
            "status": "pending",
            "description": "Optional: allow importing passphrases from CLI config.toml or exporting to it, so users who use both CLI and app can share their passphrase lists."
          }
        ]
      },
      {
        "id": 39,
        "title": "Auto-copy share link after secret creation",
        "description": "After successfully creating a secret, automatically copy the share link to the clipboard using copySensitive (which excludes from clipboard history on all platforms). The CLI does this by default via auto_copy config. Add a preference toggle (auto_copy in task #37's preferences store) so users can disable it. Show a brief toast or visual indicator confirming the copy. Do NOT auto-copy claimed secret text — that stays as a manual CopyButton action.",
        "status": "pending",
        "priority": "medium",
        "dependencies": [37],
        "subtasks": [
          {
            "id": 1,
            "title": "Auto-copy share link in ShareResult component",
            "status": "pending",
            "description": "After the share URL is generated and displayed, automatically call copySensitive(shareUrl). Respect the auto_copy preference. Show a toast or checkmark confirming 'Link copied to clipboard'."
          },
          {
            "id": 2,
            "title": "Add auto_copy toggle to Preferences",
            "status": "pending",
            "description": "Toggle in Preferences page under General section. Default: on. When off, share link is displayed but not auto-copied (user clicks CopyButton manually as today)."
          }
        ]
      }
    ]
  }
}
