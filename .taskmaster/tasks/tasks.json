{
  "master": {
    "tasks": [
      {
        "id": 6,
        "title": "Linux and cross-platform distribution",
        "description": "Linux binaries don't need code signing per se, but proper distribution channels need their own packaging and trust mechanisms. Musl builds and SHA-256 checksums are done via CI. Remaining: GPG signatures, Homebrew tap, crates.io, Linux package repos.",
        "status": "pending",
        "priority": "medium",
        "dependencies": [],
        "subtasks": [
          {
            "id": 1,
            "title": "Build static Linux binaries (musl)",
            "status": "done"
          },
          {
            "id": 2,
            "title": "Generate SHA-256 checksums and GPG signatures",
            "status": "pending",
            "description": "SHA-256 checksums are generated in CI. GPG signing of the checksums file is not yet implemented."
          },
          {
            "id": 3,
            "title": "Create Homebrew tap",
            "status": "pending"
          },
          {
            "id": 4,
            "title": "Publish to crates.io",
            "status": "pending"
          },
          {
            "id": 5,
            "title": "Evaluate APT/RPM/AUR packaging",
            "status": "pending"
          }
        ]
      },
      {
        "id": 8,
        "title": "Add coverage exclusion annotations to untestable code",
        "description": "Rust's #[coverage(off)] attribute is still unstable (tracking issue rust-lang/rust#134749). Once stabilized on stable Rust, annotate the ~129 lines of genuinely untestable code (main.rs I/O wiring, ring crypto internal errors, unreachable branches) so cargo llvm-cov reports accurate achievable coverage. See docs/test-coverage.md 'Theoretical Coverage Ceiling' section for the full list.",
        "status": "pending",
        "priority": "low",
        "dependencies": [],
        "subtasks": []
      },
      {
        "id": 15,
        "title": "Investigate app-layer IP privacy and deployment posture signaling",
        "description": "Explore whether secrt-server should truncate/hash IP addresses at the application layer (before rate limiting, owner_key derivation, or any logging) so the app itself never processes full IPs — regardless of reverse proxy configuration.\n\nRelated but distinct from task #10 (hash owner_key): this is broader and includes investigating what observable privacy properties the server could honestly assert and signal to clients.\n\nAreas to investigate:\n\n1. **App-layer IP truncation** — Truncate IPs (zero last octet for IPv4, last 80 bits for IPv6) immediately on receipt, before any use. This is a real, code-level guarantee the app controls. Evaluate impact on rate limiting accuracy and quota enforcement. Compare with the HMAC approach in task #10.\n\n2. **Client-observable signals** — What can the CLI or web client actually verify from the outside? E.g., TLS version, HSTS, absence of Server header, response headers. Identify which deployment properties are externally testable vs. trust-based.\n\n3. **Privacy posture endpoint/header** — Evaluate whether a lightweight mechanism (e.g., a response header or /.well-known/secrt.json) declaring the server's privacy posture is worthwhile. Prior art: security.txt (RFC 9116, successful), P3P (dead), Tk header (deprecated), privacy.txt IETF draft (stalled), GPC .well-known/gpc.json (active but different scope). Key tension: these are self-attested and unverifiable. Only worth doing if the CLI would act on it (e.g., warn if a server doesn't claim zero-knowledge).\n\n4. **Scope boundary** — Clearly document what the app layer can guarantee vs. what requires operator trust (reverse proxy log config, TLS termination, etc.). This is important for the project's security narrative.\n\nGoal: produce a recommendation on what (if anything) to implement, with clear rationale. May result in concrete subtasks or a 'not worth it' conclusion.",
        "status": "pending",
        "priority": "low",
        "dependencies": [],
        "subtasks": [
          {
            "id": 1,
            "title": "Evaluate app-layer IP truncation: impact on rate limiting and quota accuracy",
            "status": "pending"
          },
          {
            "id": 2,
            "title": "Inventory client-observable deployment properties (TLS, headers, etc.)",
            "status": "pending"
          },
          {
            "id": 3,
            "title": "Assess privacy posture signaling: header vs .well-known vs skip",
            "status": "pending"
          },
          {
            "id": 4,
            "title": "Document app-layer vs operator-layer privacy guarantees boundary",
            "status": "pending"
          },
          {
            "id": 5,
            "title": "Write recommendation with rationale",
            "status": "pending"
          }
        ]
      }
    ]
  }
}
